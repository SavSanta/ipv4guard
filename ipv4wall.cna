 debug(8)
# Profile
# Optimization Info that may relate

beacon_command_register(
	"ipv4check",
	"IP helper tool",
	"Usage: IPv4 helper script to determine available IP address or number of usable hosts in a subnet. \nipv4check <ADDR>/<CIDR> <hostcount | hosts>\nipv4check <ADDR> <NETMASK> <hostcount | hosts>\nExample:\n\tipv4check 192.168.1.1/24 hostcount\n\tipv4check 192.168.1.1 255.255.255.0 hosts\n");


global('$baseipnum $netmasknum 
$quadsymb
$nmquadsymb
$cidrnum
$ipsymb
$cidrsymb
$nmsymb
$hosts
')

sub ipv4calc {
    
    local('$splitted $action');

    if (indexOf($2, "/"))
    {
        $splitted = split("/", $2);
        blog2($1, "Assuming CIDR address.");
        iff(vdateip($1, $splitted[0]), ticks(), exit(["ERROR: IP validation"]));
        iff(vdatecidr($1, $splitted[1]), ticks(), exit(["ERROR: CIDR validation"]));
        $cidrsymb = $splitted[1];
        $action = $3;
    }
    else if (($2 ne $null) && ($3 ne $null))
    {
    println("$2 is arg2, and $3 is arg3");
    	$splitted = split(" ", $2);
        blog2($1, "Assuming IP Addr: $2 with Netmask: $3");
        iff(vdateip($1, $2), ticks(), exit(["ERROR: IPAddr validation"]));
        iff(vdateip($1, $3), ticks(), exit(["ERROR: Netmask validation"]));
        $cidrsymb = %netmask2cidr[$3];
        $action = $4;
    }
    else 
    {  println("Error else for $2 is arg2, and $3 is arg3");
        berror("Couldnt parse addr netmask");
        throw("IPAddr-Netmask Error.");
        exit([""]);
    }
    
   $ipsymb = $splitted[0];
   $quadsymb = split('\.', $splitted[0]);

   setbaseipnum($1);
   setnetmasknum($1);
   setarrayallips($1);
   
   if ($action ismatch 'hostcount')
   {
	printnumhosts($1);
   }
   else if ($action ismatch 'hosts')
   {
   	printallhosts($1);
   }
   else if ($action ismatch 'gethosts')
   {
   	return $hosts;
   }
   else
   {
   	println("Unsupported Action.");
   	println("Errrrrrrorrrrrrrrrr");
   	exit(["ERROR: Unsupported action."]);
   }

}

sub vdatecidr {
    local('$splitted');
    
    if ("$2" !in %cidr2hosts)
    {
        berror($1, "Invalid CIDR Mask: $2");
        return false;
    }
    else 
    {
        return true;
    }

 }
 
 sub vdateip { 

    if ("$2" ismatch '((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}')
    {
        return true;
    }
    else 
    {
    	berror($1, "ERROR: Invalid IPv4 address: $2");
        return false;
    }
 }

sub setbaseipnum {

    local('$n $i $val');
    $i = 24;
    $val = 0;
    $baseipnum = 0;

    for ($n = 0; $n < 4; $n++) {
    
        $val = casti($quadsymb[$n], 'i');

        if ($val != ($val & 0xff)) {

           berror($1, "Invalid IP address: $ipsymb");
        }
    $baseipnum += $val << $i;
    $i = $i - 8;
    }

 }

sub setnetmasknum {
    local('$n $i $val');
    
    if (casti($cidrsymb, 'i') > 0)
    {
        foreach $k => $v (%netmask2cidr)
        {
           if ($v eq $cidrsymb)
           {
              $nmsymb = $k;
           }
        }
    }

    $i = 24;
    $val = 0;
    $netmasknum = 0;

    $nmquadsymb = split('\.', $nmsymb);
    
    if ($nmquadsymb[0] > 255) {
            berror($1, "Invalid initial netmask: $nmsymb");
            return;
        }

    for ($n = 0; $n < 4; $n++) {
    
        $val = casti($nmquadsymb[$n], 'i');

        if ($val != ($val & 0xff)) {
           berror($1, "Invalid netmask: $nmsymb");
           return;
        }
    $netmasknum += $val << $i;
    $i = $i - 8;
    }

}

sub setarrayallips {

    # Get an array of all the IP addresses available for the IP and netmask/CIDR

    local('$res $n $ip $numbits $numips $currip $baseip');

	#assert $nmquadsymb != $null : "invalid nmsymb found - $nmquadsymb :s";
        #blog2($1, "baseipnum is $baseipnum !");
        #blog2($1, "netmasknum is $netmasknum !");

        $res = @();
        for ($numbits = 0; $numbits < 32; $numbits++) {

            if (($netmasknum << $numbits) == 0) {
                break;
            }
        }
        
        $numips = 0;
        for ($n = 0; $n < (32 - $numbits); $n++) {

            $numips = $numips << 1;
            $numips = $numips | 1;
        }

        $baseip = $baseipnum & $netmasknum;
        for ($n = 1; ($n < $numips) ; $n++) {

            $currip = $baseip + $n;
            $ip = ipnum2ipsymb($currip);
            add($res, $ip, -1);
         }
         
        $hosts = $res;
}

sub ipnum2ipsymb { 
       
       # Technically the shift for loop required an unsigned mathematical right shift but not an option in AggScript. 
       # Altho Sleep seems to implicate the internal representation is 32bit signed. 
       # However issues encountered unless passed in param is an unsigned java 64-Bit long type. At least for most types over the 32-bit limit.
       # IE if there are more human readable representation issues. Here may be the culprit.
       # Also dont allow direct interfacing from humans interface.

       local('$q $numip $sh $res');
       $q = @();
       $numip = long($1);
       
       for ($sh = 24; $sh > 0; $sh -= 8) {
            add($q, (($numip >> $sh) & 0xff));
        }
        add($q, ($numip & 0xff));
        $res = join('.', reverse($q));
        
        return $res;
}

sub printnumhosts {

	local('$hc');
	$hc = size($hosts);
	blog2($1, "Hostcount: $hc");
	
}

sub printallhosts { 

	local('$hv');
	$hv = join(", ", $hosts);
	blog2($1, "Hosts: $hv");
}

sub testcase { 

   # >>>>>>>>>> Validate On G
   blog2($1, "validation passed");
   blog2($1, "Symb ip: $ipsymb");
   blog2($1, "CIDR $cidrsymb");
   blog2($1, "Quads ip: $quadsymb");
   blog2($1, "Base GAWD IP is: $baseipnum");
   blog2($1, "------------vv----------------");
   blog2($1, "Symbolico Netmask ip: $nmsymb");
   blog2($1, "Netmask Numericals is: $netmasknum");
   blog2($1, "Netmask Symbol $nmsymb");
   blog2($1, "Netmask Quads: $nmquadsymb");
   
   blog2($1, ipnum2ipsymb(3356232971));
   blog2($1, ipnum2ipsymb(65793));
   blog2($1, ipnum2ipsymb(65793));
   blog2($1, ipnum2ipsymb(65793));

}

%cidr2hosts = %(

1	=> "2147483392" ,
2	=> "1073741696" ,
3	=> "536870848"  ,
4	=> "268435424"  ,
5	=> "134217712"  ,
6	=> "67108856"   ,
7	=> "33554428"   ,
8	=> "16777214"   ,
9	=> "8388352"    ,
10	=> "4194176"    ,
11	=> "2097088"    ,
12	=> "1048544"    ,
13	=> "524272"     ,
14	=> "262136"     ,
15	=> "131068"     ,
16	=> "65024"      ,
17	=> "32512"      ,
18	=> "16256"      ,
19	=> "8128"       ,
20	=> "4064"       ,
21	=> "2032"       ,
22	=> "1016"       ,
23	=> "508"        ,
24	=> "254"        ,
25	=> "124"        ,
26	=> "62"         ,
27	=> "30"         ,
28	=> "14"         ,
29	=> "6"          ,
30	=> "2"          ,
31	=> $null        ,
32	=> "1"     

);

%netmask2cidr = 
%(

128.0.0.0	  => "1" ,
192.0.0.0	  => "2" ,
224.0.0.0	  => "3" ,
240.0.0.0	  => "4" ,
248.0.0.0	  => "5" ,
252.0.0.0	  => "6" ,
254.0.0.0	  => "7" ,
255.0.0.0 	  => "8" ,
255.128.0.0       => "9" ,
255.192.0.0       => "10",
255.224.0.0       => "11",
255.240.0.0       => "12",
255.248.0.0       => "13",
255.252.0.0       => "14",
255.254.0.0       => "15",
255.255.0.0       => "16",
255.255.128.0     => "17",
255.255.192.0     => "18",
255.255.224.0     => "19",
255.255.240.0     => "20",
255.255.248.0     => "21",
255.255.252.0     => "22",
255.255.254.0     => "23",
255.255.255.0     => "24",
255.255.255.128   => "25",
255.255.255.192   => "26",
255.255.255.224   => "27",
255.255.255.240   => "28",
255.255.255.248   => "29",
255.255.255.252   => "30",
255.255.255.254   => "31",
255.255.255.255   => "32"
);

alias("ipv4check", &ipv4calc);

#-------------------------
global('$ac $guardips $bid')
$guardips = @();

# Change ips variable name as it has logical reading naming conflicts

sub handle {

    local('$bid $ip $ips');
    # Update Auto Task Cancel setting	
    $ac = $3['autocancel'];
    $ap = $3['combo'];

    # Grab IP address
    $ip = $3['ipaddr'];

    #blog2($bid, "Check the DATA IN IP var ---> $ip");
    #println("Beacone ID is $bid || Check the DATA IN IP var ---> $ip");
 
    # Process ips    
    #$ips = fireAlias($1, "ipv4check", "169.254.254.254/30 gethosts");
    $ips = ipv4calc($bid, $ip, "gethosts") ;
    
    # Dispatch to add/remove/list

    if ($ap ismatch 'Add')
    {
	add_ips($ips);
	blog($bid, "Add action complete.") ;        
    }
    else if ($ap ismatch 'Remove')
    {
	remove_ips($ips);
	blog($bid, "Remove action complete.") ;
    }
    else if ($ap ismatch 'List')
    {
	query_ips();
	blog($bid, "List action complete.") ;
    }
    else 
    {
    	berror($bid, "no match for action in IPGuard") ;
    	return;
    }

}

sub add_ips { 

	addAll($guardips, flatten($1));
}

sub remove_ips {

	removeAll($guardips, flatten($1));

}


sub query_ips {

    blog2($bid, "Hosts: $guardips");

}

on beacon_input {
    local('$iphit');

    # is this the best loop for this?
    # My preferred regex with regex [ismatch '((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}'] produces partitioned chunk arary with [$hit = matched()] and misses last octet. So cant use hence alt regex.
    # This out of all regex options tried is the best fit for AGS limitation.
    
    
   # TODO: Need a match logic for CIDR IP inputs too
   # TODO: In regards to above. Settle on regex. Regex with greater than 4 digits in the last octet either require hte a \s to delineate which then requires a trimmer. 
   while ("$3" hasmatch '(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})') 
   {
   	$iphit = matched();
   	
   	if ($iphit in $guardips) 
   	{
		if ($ac == true)
		{
			blog2($1, "IP match - $iphit - found in IPGuard.\nsTask Autoclearing is ENABLED. Clearing all pending tasks for beacon.");
			bclear($1);
			blog2($1, "Tasks Cleared.");
		}
		else
		{
			blog2($1, " Line -> $3");
			blog2($1, "IP match - $iphit - found in IPGuard.");
			blog2($1, "Verify your entered command.");
		}
	}
    }
    return;
}

popup beacon {
        item "IPv4 Guard" {
                local('$dialog %defaults');

                # setup our defaults
                %defaults["autocancel"] = $autocancel;
                %defaults["ipaddr"] = "169.254.254.254/32";
                %defaults['bid'] = $1;

                # create our dialog
                $dialog = dialog("IPv4 Guard", %defaults, &handle);
                dialog_description($dialog, "IPv4 Guard - Add or Remove IPv4 addresses to the beacon b	locklist.\nWhen a command with a blocklist/offlimit IP is detected in a beacon, then automatically cancels ALL pending beacon tasks for that beacon.");
                drow_text($dialog, "ipaddr",  "IP Address: ");
                drow_combobox($dialog, "combo", "Action For IP Guard", @("Add", "Remove", "List"));
                drow_checkbox($dialog, "autocancel", "Cancel Pending Tasks on blocked IP", "(Globally affects on *ANY* blocked IP!)");
                dbutton_action($dialog, "Perform");
                # show our dialog
                dialog_show($dialog);
        }
}
