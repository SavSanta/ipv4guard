

beacon_command_register(
	"ipv4check",
	"IP helper tools",
	"Usage: IPv4 helper script to determine available IP address or number of usable hosts in a subnet. \nipv4check hostcount <ADDR>/<CIDR>\nipv4check hostcount <ADDR> <NETMASK>\n");


global('$baseipnum $netmasknum 
$quadsymb
$nmquadsymb
$cidrnum
$ipsymb
$cidrsymb
$nmsymb
$hosts
')

alias ipv4check {
    
    local('$splitted');

    if (indexOf($2, "/"))
    {
        $splitted = split("/", $2);
        blog2($1, "Assuming CIDR address.");
        vdateip($1, $splitted[0]);
        vdatecidr($1, $splitted[1]);
        $cidrsymb = $splitted[1];
    }
    else 
    {
        $splitted = split(" ", $2);
        blog2($1, "Assuming IP Addr: $splitted[0] and Netmask: $splitted[1]");
        if (size($splitted) == 2)
        {
            vdateip($1, $splitted[0]);
            vdateip($1, $splitted[1]);
            $cidrsymb = %netmask2cidr($splitted[1]);
        }
        else 
        {
            berror("Couldnt parse addr netmask");
            throw("Addr-Netmask Error.");
        }
        
    }
    
   $ipsymb = $splitted[0];
   $quadsymb = split('\.', $splitted[0]);

   setbaseipnum($1);
   setnetmasknum($1);
   setarrayallips();
   getnumhosts($1);

}

sub vdatecidr {
    local('$splitted');
    
    if ("$2" !in %cidr2hosts)
    {
        berror($1, "Invalid CIDR Mask: $2");
        throw("CIDR Error.");
    }

 }
 
 sub vdateip { 
    local('$splitted');
    
    if ( "$2" !ismatch '^((25[0-5]|(2[0-4]|1\d|[1-9]|)\d)\.?\b){4}$')
    {
        berror($1, "Not a valid IPv4 address: $2");
        throw("IPV4 Error.");
    }
 
 }


sub setbaseipnum {

    local('$n $i $val');
    $i = 24;
    $val = 0;
    $baseipnum = 0;

    for ($n = 0; $n < 4; $n++) {
    
        $val = casti($quadsymb[$n], 'i');

        if ($val != ($val & 0xff)) {

           berror($1, "Invalid IP address: $ipsymb");
        }
    $baseipnum += $val << $i;
    $i = $i - 8;
    }

 }

sub setnetmasknum {
    local('$n $i $val');
    
    if (casti($cidrsymb, 'i') > 0)
    {
        foreach $k => $v (%netmask2cidr)
        {
           if ($v eq $cidrsymb)
           {
              $nmsymb = $k;
           }
        }
    }

    $i = 24;
    $val = 0;
    $netmasknum = 0;

    $nmquadsymb = split('\.', $nmsymb);
    
    if ($nmquadsymb[0] > 255) {
            berror($1, "Invalid initial netmask: $nmsymb");
            return;
        }

    for ($n = 0; $n < 4; $n++) {
    
        $val = casti($nmquadsymb[$n], 'i');

        if ($val != ($val & 0xff)) {
           berror($1, "Invalid netmask: $nmsymb");
           return;
        }
    $netmasknum += $val << $i;
    $i = $i - 8;
    }

}

sub setarrayallips {

    # Get an array of all the IP addresses available for the IP and netmask/CIDR

    local('$res $n $ip $numbits $numips $currip $baseip');

	#assert $nmquadsymb != $null : "invalid nmsymb found - $nmquadsymb :s";
        #blog2($1, "baseipnum is $baseipnum !");
        #blog2($1, "netmasknum is $netmasknum !");

        $res = @();
        for ($numbits = 0; $numbits < 32; $numbits++) {

            if (($netmasknum << $numbits) == 0) {
                break;
            }
        }
        
        $numips = 0;
        for ($n = 0; $n < (32 - $numbits); $n++) {

            $numips = $numips << 1;
            $numips = $numips | 1;
        }

        $baseip = $baseipnum & $netmasknum;
        for ($n = 1; ($n < $numips) ; $n++) {

            $currip = $baseip + $n;
            $ip = ipnum2ipsymb($currip);
            add($res, $ip, -1);
         }
         
        $hosts = $res;
}

sub getnumhosts { blog2($1, "Number of hosts is: "); blog2($1, size($hosts)); blog2($1, "end transission"); }	

sub getipnum { }

sub getipsymb { }

sub ipnum2ipsymb { 
       
       # Technically the shift for loop required an unsigned mathematical right shift but not an option in AggScript. 
       # Altho Sleep seems to implicate the internal representation is 32bit signed. 
       # However issues encountered unless passed in param is an unsigned java 64-Bit long type. At least for most types over the 32-bit limit.
       # IE if there are more human readable representation issues. Here may be the culprit.
       # Also dont allow direct interfacing from humans interface.

       local('$q $numip $sh $res');
       $q = @();
       $numip = long($1);
       
       for ($sh = 24; $sh > 0; $sh -= 8) {
            add($q, (($numip >> $sh) & 0xff));
        }
        add($q, ($numip & 0xff));
        $res = join('.', reverse($q));
        
        return $res;
}

sub testcase { 

   # >>>>>>>>>> Validate On G
   blog2($1, "validation passed");
   blog2($1, "Symb ip: $ipsymb");
   blog2($1, "CIDR $cidrsymb");
   blog2($1, "Quads ip: $quadsymb");
   blog2($1, "Base GAWD IP is: $baseipnum");
   blog2($1, "------------vv----------------");
   blog2($1, "Symbolico Netmask ip: $nmsymb");
   blog2($1, "Netmask Numericals is: $netmasknum");
   blog2($1, "Netmask Symbol $nmsymb");
   blog2($1, "Netmask Quads: $nmquadsymb");
   
   blog2($1, ipnum2ipsymb(3356232971));
   blog2($1, ipnum2ipsymb(65793));
   blog2($1, ipnum2ipsymb(65793));
   blog2($1, ipnum2ipsymb(65793));

}

%cidr2hosts = %(

1	=> "2147483392" ,
2	=> "1073741696" ,
3	=> "536870848"  ,
4	=> "268435424"  ,
5	=> "134217712"  ,
6	=> "67108856"   ,
7	=> "33554428"   ,
8	=> "16777214"   ,
9	=> "8388352"    ,
10	=> "4194176"    ,
11	=> "2097088"    ,
12	=> "1048544"    ,
13	=> "524272"     ,
14	=> "262136"     ,
15	=> "131068"     ,
16	=> "65024"      ,
17	=> "32512"      ,
18	=> "16256"      ,
19	=> "8128"       ,
20	=> "4064"       ,
21	=> "2032"       ,
22	=> "1016"       ,
23	=> "508"        ,
24	=> "254"        ,
25	=> "124"        ,
26	=> "62"         ,
27	=> "30"         ,
28	=> "14"         ,
29	=> "6"          ,
30	=> "2"          ,
31	=> $null        ,
32	=> "1"     

);

%netmask2cidr = 
%(

128.0.0.0	  => "1" ,
192.0.0.0	  => "2" ,
224.0.0.0	  => "3" ,
240.0.0.0	  => "4" ,
248.0.0.0	  => "5" ,
252.0.0.0	  => "6" ,
254.0.0.0	  => "7" ,
255.0.0.0 	  => "8" ,
255.128.0.0       => "9" ,
255.192.0.0       => "10",
255.224.0.0       => "11",
255.240.0.0       => "12",
255.248.0.0       => "13",
255.252.0.0       => "14",
255.254.0.0       => "15",
255.255.0.0       => "16",
255.255.128.0     => "17",
255.255.192.0     => "18",
255.255.224.0     => "19",
255.255.240.0     => "20",
255.255.248.0     => "21",
255.255.252.0     => "22",
255.255.254.0     => "23",
255.255.255.0     => "24",
255.255.255.128   => "25",
255.255.255.192   => "26",
255.255.255.224   => "27",
255.255.255.240   => "28",
255.255.255.248   => "29",
255.255.255.252   => "30",
255.255.255.254   => "31",
255.255.255.255   => "32"
);




